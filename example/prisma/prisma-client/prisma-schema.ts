// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
  type AggregateBookmark {
    count: Int!
  }

  type AggregateUser {
    count: Int!
  }

  type BatchPayload {
    count: Long!
  }

  type Bookmark {
    id: ID!
    label: String!
    page: String!
    numberOfVisits: Int!
    user: User!
  }

  type BookmarkConnection {
    pageInfo: PageInfo!
    edges: [BookmarkEdge]!
    aggregate: AggregateBookmark!
  }

  input BookmarkCreateInput {
    id: ID
    label: String!
    page: String!
    numberOfVisits: Int!
    user: UserCreateOneWithoutBookmarksInput!
  }

  input BookmarkCreateManyWithoutUserInput {
    create: [BookmarkCreateWithoutUserInput!]
    connect: [BookmarkWhereUniqueInput!]
  }

  input BookmarkCreateWithoutUserInput {
    id: ID
    label: String!
    page: String!
    numberOfVisits: Int!
  }

  type BookmarkEdge {
    node: Bookmark!
    cursor: String!
  }

  enum BookmarkOrderByInput {
    id_ASC
    id_DESC
    label_ASC
    label_DESC
    page_ASC
    page_DESC
    numberOfVisits_ASC
    numberOfVisits_DESC
  }

  type BookmarkPreviousValues {
    id: ID!
    label: String!
    page: String!
    numberOfVisits: Int!
  }

  input BookmarkScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    label: String
    label_not: String
    label_in: [String!]
    label_not_in: [String!]
    label_lt: String
    label_lte: String
    label_gt: String
    label_gte: String
    label_contains: String
    label_not_contains: String
    label_starts_with: String
    label_not_starts_with: String
    label_ends_with: String
    label_not_ends_with: String
    page: String
    page_not: String
    page_in: [String!]
    page_not_in: [String!]
    page_lt: String
    page_lte: String
    page_gt: String
    page_gte: String
    page_contains: String
    page_not_contains: String
    page_starts_with: String
    page_not_starts_with: String
    page_ends_with: String
    page_not_ends_with: String
    numberOfVisits: Int
    numberOfVisits_not: Int
    numberOfVisits_in: [Int!]
    numberOfVisits_not_in: [Int!]
    numberOfVisits_lt: Int
    numberOfVisits_lte: Int
    numberOfVisits_gt: Int
    numberOfVisits_gte: Int
    AND: [BookmarkScalarWhereInput!]
    OR: [BookmarkScalarWhereInput!]
    NOT: [BookmarkScalarWhereInput!]
  }

  type BookmarkSubscriptionPayload {
    mutation: MutationType!
    node: Bookmark
    updatedFields: [String!]
    previousValues: BookmarkPreviousValues
  }

  input BookmarkSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: BookmarkWhereInput
    AND: [BookmarkSubscriptionWhereInput!]
    OR: [BookmarkSubscriptionWhereInput!]
    NOT: [BookmarkSubscriptionWhereInput!]
  }

  input BookmarkUpdateInput {
    label: String
    page: String
    numberOfVisits: Int
    user: UserUpdateOneRequiredWithoutBookmarksInput
  }

  input BookmarkUpdateManyDataInput {
    label: String
    page: String
    numberOfVisits: Int
  }

  input BookmarkUpdateManyMutationInput {
    label: String
    page: String
    numberOfVisits: Int
  }

  input BookmarkUpdateManyWithoutUserInput {
    create: [BookmarkCreateWithoutUserInput!]
    delete: [BookmarkWhereUniqueInput!]
    connect: [BookmarkWhereUniqueInput!]
    set: [BookmarkWhereUniqueInput!]
    disconnect: [BookmarkWhereUniqueInput!]
    update: [BookmarkUpdateWithWhereUniqueWithoutUserInput!]
    upsert: [BookmarkUpsertWithWhereUniqueWithoutUserInput!]
    deleteMany: [BookmarkScalarWhereInput!]
    updateMany: [BookmarkUpdateManyWithWhereNestedInput!]
  }

  input BookmarkUpdateManyWithWhereNestedInput {
    where: BookmarkScalarWhereInput!
    data: BookmarkUpdateManyDataInput!
  }

  input BookmarkUpdateWithoutUserDataInput {
    label: String
    page: String
    numberOfVisits: Int
  }

  input BookmarkUpdateWithWhereUniqueWithoutUserInput {
    where: BookmarkWhereUniqueInput!
    data: BookmarkUpdateWithoutUserDataInput!
  }

  input BookmarkUpsertWithWhereUniqueWithoutUserInput {
    where: BookmarkWhereUniqueInput!
    update: BookmarkUpdateWithoutUserDataInput!
    create: BookmarkCreateWithoutUserInput!
  }

  input BookmarkWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    label: String
    label_not: String
    label_in: [String!]
    label_not_in: [String!]
    label_lt: String
    label_lte: String
    label_gt: String
    label_gte: String
    label_contains: String
    label_not_contains: String
    label_starts_with: String
    label_not_starts_with: String
    label_ends_with: String
    label_not_ends_with: String
    page: String
    page_not: String
    page_in: [String!]
    page_not_in: [String!]
    page_lt: String
    page_lte: String
    page_gt: String
    page_gte: String
    page_contains: String
    page_not_contains: String
    page_starts_with: String
    page_not_starts_with: String
    page_ends_with: String
    page_not_ends_with: String
    numberOfVisits: Int
    numberOfVisits_not: Int
    numberOfVisits_in: [Int!]
    numberOfVisits_not_in: [Int!]
    numberOfVisits_lt: Int
    numberOfVisits_lte: Int
    numberOfVisits_gt: Int
    numberOfVisits_gte: Int
    user: UserWhereInput
    AND: [BookmarkWhereInput!]
    OR: [BookmarkWhereInput!]
    NOT: [BookmarkWhereInput!]
  }

  input BookmarkWhereUniqueInput {
    id: ID
  }

  scalar Long

  type Mutation {
    createBookmark(data: BookmarkCreateInput!): Bookmark!
    updateBookmark(
      data: BookmarkUpdateInput!
      where: BookmarkWhereUniqueInput!
    ): Bookmark
    updateManyBookmarks(
      data: BookmarkUpdateManyMutationInput!
      where: BookmarkWhereInput
    ): BatchPayload!
    upsertBookmark(
      where: BookmarkWhereUniqueInput!
      create: BookmarkCreateInput!
      update: BookmarkUpdateInput!
    ): Bookmark!
    deleteBookmark(where: BookmarkWhereUniqueInput!): Bookmark
    deleteManyBookmarks(where: BookmarkWhereInput): BatchPayload!
    createUser(data: UserCreateInput!): User!
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    updateManyUsers(
      data: UserUpdateManyMutationInput!
      where: UserWhereInput
    ): BatchPayload!
    upsertUser(
      where: UserWhereUniqueInput!
      create: UserCreateInput!
      update: UserUpdateInput!
    ): User!
    deleteUser(where: UserWhereUniqueInput!): User
    deleteManyUsers(where: UserWhereInput): BatchPayload!
  }

  enum MutationType {
    CREATED
    UPDATED
    DELETED
  }

  interface Node {
    id: ID!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Query {
    bookmark(where: BookmarkWhereUniqueInput!): Bookmark
    bookmarks(
      where: BookmarkWhereInput
      orderBy: BookmarkOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Bookmark]!
    bookmarksConnection(
      where: BookmarkWhereInput
      orderBy: BookmarkOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): BookmarkConnection!
    user(where: UserWhereUniqueInput!): User
    users(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [User]!
    usersConnection(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): UserConnection!
    node(id: ID!): Node
  }

  type Subscription {
    bookmark(where: BookmarkSubscriptionWhereInput): BookmarkSubscriptionPayload
    user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  }

  type User {
    id: ID!
    name: String!
    phoneNumber: String!
    bookmarks(
      where: BookmarkWhereInput
      orderBy: BookmarkOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Bookmark!]
  }

  type UserConnection {
    pageInfo: PageInfo!
    edges: [UserEdge]!
    aggregate: AggregateUser!
  }

  input UserCreateInput {
    id: ID
    name: String!
    phoneNumber: String!
    bookmarks: BookmarkCreateManyWithoutUserInput
  }

  input UserCreateOneWithoutBookmarksInput {
    create: UserCreateWithoutBookmarksInput
    connect: UserWhereUniqueInput
  }

  input UserCreateWithoutBookmarksInput {
    id: ID
    name: String!
    phoneNumber: String!
  }

  type UserEdge {
    node: User!
    cursor: String!
  }

  enum UserOrderByInput {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    phoneNumber_ASC
    phoneNumber_DESC
  }

  type UserPreviousValues {
    id: ID!
    name: String!
    phoneNumber: String!
  }

  type UserSubscriptionPayload {
    mutation: MutationType!
    node: User
    updatedFields: [String!]
    previousValues: UserPreviousValues
  }

  input UserSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: UserWhereInput
    AND: [UserSubscriptionWhereInput!]
    OR: [UserSubscriptionWhereInput!]
    NOT: [UserSubscriptionWhereInput!]
  }

  input UserUpdateInput {
    name: String
    phoneNumber: String
    bookmarks: BookmarkUpdateManyWithoutUserInput
  }

  input UserUpdateManyMutationInput {
    name: String
    phoneNumber: String
  }

  input UserUpdateOneRequiredWithoutBookmarksInput {
    create: UserCreateWithoutBookmarksInput
    update: UserUpdateWithoutBookmarksDataInput
    upsert: UserUpsertWithoutBookmarksInput
    connect: UserWhereUniqueInput
  }

  input UserUpdateWithoutBookmarksDataInput {
    name: String
    phoneNumber: String
  }

  input UserUpsertWithoutBookmarksInput {
    update: UserUpdateWithoutBookmarksDataInput!
    create: UserCreateWithoutBookmarksInput!
  }

  input UserWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    phoneNumber: String
    phoneNumber_not: String
    phoneNumber_in: [String!]
    phoneNumber_not_in: [String!]
    phoneNumber_lt: String
    phoneNumber_lte: String
    phoneNumber_gt: String
    phoneNumber_gte: String
    phoneNumber_contains: String
    phoneNumber_not_contains: String
    phoneNumber_starts_with: String
    phoneNumber_not_starts_with: String
    phoneNumber_ends_with: String
    phoneNumber_not_ends_with: String
    bookmarks_every: BookmarkWhereInput
    bookmarks_some: BookmarkWhereInput
    bookmarks_none: BookmarkWhereInput
    AND: [UserWhereInput!]
    OR: [UserWhereInput!]
    NOT: [UserWhereInput!]
  }

  input UserWhereUniqueInput {
    id: ID
  }
`
